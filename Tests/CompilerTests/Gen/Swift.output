import Foundation
import Otter

struct Interest: Hashable, Sendable, Identifiable, RowDecodable {
    let id: Int
    let value: String
    let userId: Int?
    
    static let nonOptionalIndices: [Int32] = [0, 1]
    
    init(
        row: borrowing Otter.Row,
        startingAt start: Int32
    ) throws(Otter.OtterError) {
        self.id = try row.value(at: start + 0)
        self.value = try row.value(at: start + 1)
        self.userId = try row.value(at: start + 2)
    }
    
    init(
        id: Int,
        value: String,
        userId: Int?
    ) {
        self.id = id
        self.value = value
        self.userId = userId
    }
}

struct User: Hashable, Sendable, Identifiable, RowDecodable {
    let id: Int
    let firstName: String
    let lastName: String
    let preference: Bool?
    let favoriteNumber: Int?
    let randomValue: SQLAny?
    let bornOn: Date?
    let fullName: String
    
    static let nonOptionalIndices: [Int32] = [0, 1, 2, 7]
    
    init(
        row: borrowing Otter.Row,
        startingAt start: Int32
    ) throws(Otter.OtterError) {
        self.id = try row.value(at: start + 0)
        self.firstName = try row.value(at: start + 1)
        self.lastName = try row.value(at: start + 2)
        self.preference = try row.optionalValue(at: start + 3, using: BoolDatabaseValueAdapter.self, storage: Int.self)
        self.favoriteNumber = try row.value(at: start + 4)
        self.randomValue = try row.value(at: start + 5)
        self.bornOn = try row.optionalValue(at: start + 6, using: CustomDateDatabaseValueAdapter.self, storage: String.self)
        self.fullName = try row.value(at: start + 7)
    }
    
    init(
        id: Int,
        firstName: String,
        lastName: String,
        preference: Bool?,
        favoriteNumber: Int?,
        randomValue: SQLAny?,
        bornOn: Date?,
        fullName: String
    ) {
        self.id = id
        self.firstName = firstName
        self.lastName = lastName
        self.preference = preference
        self.favoriteNumber = favoriteNumber
        self.randomValue = randomValue
        self.bornOn = bornOn
        self.fullName = fullName
    }
}

struct InsertUserInput: Hashable, Sendable, Identifiable {
    let id: Int
    let firstName: String
    let lastName: String
    let preference: Bool?
    let favoriteNumber: Int?
    let randomValue: SQLAny?
    let bornOn: Date?
}

struct SelectUserWithManyInputsInput: Hashable, Sendable, Identifiable {
    let id: Int
    let firstName: String
}

@dynamicMemberLookup
struct SelectUserWithManyInputsOutput: Hashable, Sendable, RowDecodable {
    let user: User
    let favoriteNumber: Int
    
    static let nonOptionalIndices: [Int32] = []
    
    init(
        row: borrowing Otter.Row,
        startingAt start: Int32
    ) throws(Otter.OtterError) {
        self.user = try row.embedded(at: start + 0)
        self.favoriteNumber = try row.value(at: start + 1)
    }
    
    init(
        user: User,
        favoriteNumber: Int
    ) {
        self.user = user
        self.favoriteNumber = favoriteNumber
    }
    
    subscript<Value>(dynamicMember dynamicMember: KeyPath<User, Value>) -> Value {
        self.user[keyPath: dynamicMember]
    }
}

@dynamicMemberLookup
struct SelectWithInterestOutput: Hashable, Sendable, RowDecodable {
    let user: User
    let interest: Interest
    
    static let nonOptionalIndices: [Int32] = []
    
    init(
        row: borrowing Otter.Row,
        startingAt start: Int32
    ) throws(Otter.OtterError) {
        self.user = try row.embedded(at: start + 0)
        self.interest = try row.embedded(at: start + 1)
    }
    
    init(
        user: User,
        interest: Interest
    ) {
        self.user = user
        self.interest = interest
    }
    
    subscript<Value>(dynamicMember dynamicMember: KeyPath<User, Value>) -> Value {
        self.user[keyPath: dynamicMember]
    }
    
    subscript<Value>(dynamicMember dynamicMember: KeyPath<Interest, Value>) -> Value {
        self.interest[keyPath: dynamicMember]
    }
}

@dynamicMemberLookup
struct SelectWithOptionalInterestOutput: Hashable, Sendable, RowDecodable {
    let user: User
    let interest: Interest?
    
    static let nonOptionalIndices: [Int32] = []
    
    init(
        row: borrowing Otter.Row,
        startingAt start: Int32
    ) throws(Otter.OtterError) {
        self.user = try row.embedded(at: start + 0)
        self.interest = try row.optionallyEmbedded(at: start + 1)
    }
    
    init(
        user: User,
        interest: Interest?
    ) {
        self.user = user
        self.interest = interest
    }
    
    subscript<Value>(dynamicMember dynamicMember: KeyPath<User, Value>) -> Value {
        self.user[keyPath: dynamicMember]
    }
    
    subscript<Value>(dynamicMember dynamicMember: KeyPath<Interest, Value>) -> Value? {
        self.interest?[keyPath: dynamicMember]
    }
}

protocol QueriesQueries {
    associatedtype InsertUser: InsertUserQuery
    var insertUser: InsertUser { get }
    associatedtype SelectUsers: SelectUsersQuery
    var selectUsers: SelectUsers { get }
    associatedtype SelectUserById: SelectUserByIdQuery
    var selectUserById: SelectUserById { get }
    associatedtype SelectUserByIds: SelectUserByIdsQuery
    var selectUserByIds: SelectUserByIds { get }
    associatedtype SelectUserByName: SelectUserByNameQuery
    var selectUserByName: SelectUserByName { get }
    associatedtype SelectUserWithManyInputs: SelectUserWithManyInputsQuery
    var selectUserWithManyInputs: SelectUserWithManyInputs { get }
    associatedtype SelectWithInterest: SelectWithInterestQuery
    var selectWithInterest: SelectWithInterest { get }
    associatedtype SelectWithOptionalInterest: SelectWithOptionalInterestQuery
    var selectWithOptionalInterest: SelectWithOptionalInterest { get }
}

struct QueriesQueriesNoop: QueriesQueries {
    let insertUser: AnyQuery<InsertUserInput, ()>
    let selectUsers: AnyQuery<(), [User]>
    let selectUserById: AnyQuery<Int, User?>
    let selectUserByIds: AnyQuery<[Int], [User]>
    let selectUserByName: AnyQuery<String, [User]>
    let selectUserWithManyInputs: AnyQuery<SelectUserWithManyInputsInput, SelectUserWithManyInputsOutput?>
    let selectWithInterest: AnyQuery<(), [SelectWithInterestOutput]>
    let selectWithOptionalInterest: AnyQuery<(), [SelectWithOptionalInterestOutput]>
    
    init(
        insertUser: any InsertUserQuery = Queries.Just(),
        selectUsers: any SelectUsersQuery = Queries.Just(),
        selectUserById: any SelectUserByIdQuery = Queries.Just(),
        selectUserByIds: any SelectUserByIdsQuery = Queries.Just(),
        selectUserByName: any SelectUserByNameQuery = Queries.Just(),
        selectUserWithManyInputs: any SelectUserWithManyInputsQuery = Queries.Just(),
        selectWithInterest: any SelectWithInterestQuery = Queries.Just(),
        selectWithOptionalInterest: any SelectWithOptionalInterestQuery = Queries.Just()
    ) {
        self.insertUser = insertUser.eraseToAnyQuery()
        self.selectUsers = selectUsers.eraseToAnyQuery()
        self.selectUserById = selectUserById.eraseToAnyQuery()
        self.selectUserByIds = selectUserByIds.eraseToAnyQuery()
        self.selectUserByName = selectUserByName.eraseToAnyQuery()
        self.selectUserWithManyInputs = selectUserWithManyInputs.eraseToAnyQuery()
        self.selectWithInterest = selectWithInterest.eraseToAnyQuery()
        self.selectWithOptionalInterest = selectWithOptionalInterest.eraseToAnyQuery()
    }
}

struct QueriesQueriesImpl: QueriesQueries {
    let connection: any Connection
    
    var insertUser: AnyDatabaseQuery<InsertUserInput, ()> {
        AnyDatabaseQuery<InsertUserInput, ()>(
            .write,
            in: connection,
            watchingTables: ["user"]
        ) { input, tx in
            var statement = try Otter.Statement(
                """
                INSERT INTO user VALUES (?, ?, ?, ?, ?, ?, ?)
                """,
                transaction: tx
            )
            try statement.bind(value: input.id, to: 1)
            try statement.bind(value: input.firstName, to: 2)
            try statement.bind(value: input.lastName, to: 3)
            try statement.bind(value: input.preference, to: 4, using: BoolDatabaseValueAdapter.self, as: Int.self)
            try statement.bind(value: input.favoriteNumber, to: 5)
            try statement.bind(value: input.randomValue, to: 6)
            try statement.bind(value: input.bornOn, to: 7, using: CustomDateDatabaseValueAdapter.self, as: String.self)
            _ = try statement.step()
        }
    }
    
    var selectUsers: AnyDatabaseQuery<(), [User]> {
        AnyDatabaseQuery<(), [User]>(
            .read,
            in: connection,
            watchingTables: ["user"]
        ) { input, tx in
            let statement = try Otter.Statement(
                """
                SELECT * FROM user
                """,
                transaction: tx
            )
            return try statement.fetchAll()
        }
    }
    
    var selectUserById: AnyDatabaseQuery<Int, User?> {
        AnyDatabaseQuery<Int, User?>(
            .read,
            in: connection,
            watchingTables: ["user"]
        ) { input, tx in
            var statement = try Otter.Statement(
                """
                SELECT * FROM user WHERE id = ?
                """,
                transaction: tx
            )
            try statement.bind(value: input, to: 1)
            return try statement.fetchOne()
        }
    }
    
    var selectUserByIds: AnyDatabaseQuery<[Int], [User]> {
        AnyDatabaseQuery<[Int], [User]>(
            .read,
            in: connection,
            watchingTables: ["user"]
        ) { input, tx in
            var statement = try Otter.Statement(
                """
                SELECT * FROM user WHERE id IN (\(input.sqlQuestionMarks))
                """,
                transaction: tx
            )
            for element in input {
                try statement.bind(value: element.input, to: 1)
            }
            return try statement.fetchAll()
        }
    }
    
    var selectUserByName: AnyDatabaseQuery<String, [User]> {
        AnyDatabaseQuery<String, [User]>(
            .read,
            in: connection,
            watchingTables: ["user"]
        ) { input, tx in
            var statement = try Otter.Statement(
                """
                SELECT * FROM user WHERE fullName LIKE ?
                """,
                transaction: tx
            )
            try statement.bind(value: input, to: 1)
            return try statement.fetchAll()
        }
    }
    
    var selectUserWithManyInputs: AnyDatabaseQuery<SelectUserWithManyInputsInput, SelectUserWithManyInputsOutput?> {
        AnyDatabaseQuery<SelectUserWithManyInputsInput, SelectUserWithManyInputsOutput?>(
            .read,
            in: connection,
            watchingTables: ["user"]
        ) { input, tx in
            var statement = try Otter.Statement(
                """
                SELECT *, 1 AS favoriteNumber FROM user WHERE id = ? AND firstName = ?
                """,
                transaction: tx
            )
            try statement.bind(value: input.id, to: 1)
            try statement.bind(value: input.firstName, to: 2)
            return try statement.fetchOne()
        }
    }
    
    var selectWithInterest: AnyDatabaseQuery<(), [SelectWithInterestOutput]> {
        AnyDatabaseQuery<(), [SelectWithInterestOutput]>(
            .read,
            in: connection,
            watchingTables: ["interest","user"]
        ) { input, tx in
            let statement = try Otter.Statement(
                """
                SELECT user.*, interest.* FROM user INNER JOIN interest ON user.id = interest.userId
                """,
                transaction: tx
            )
            return try statement.fetchAll()
        }
    }
    
    var selectWithOptionalInterest: AnyDatabaseQuery<(), [SelectWithOptionalInterestOutput]> {
        AnyDatabaseQuery<(), [SelectWithOptionalInterestOutput]>(
            .read,
            in: connection,
            watchingTables: ["interest","user"]
        ) { input, tx in
            let statement = try Otter.Statement(
                """
                SELECT user.*, interest.* FROM user LEFT OUTER JOIN interest ON user.id = interest.userId
                """,
                transaction: tx
            )
            return try statement.fetchAll()
        }
    }
}

struct DB: Database{
    let connection: any Otter.Connection
    
    static var migrations: [String] {
        return [
            """
            CREATE TABLE user (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                firstName TEXT NOT NULL,
                lastName TEXT NOT NULL,
                preference INTEGER ,
                favoriteNumber INTEGER,
                randomValue ANY,
                bornOn TEXT ,
                fullName TEXT NOT NULL GENERATED ALWAYS AS (firstName || ' ' || lastName)
            );
            """,
            """
            CREATE TABLE interest (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                value TEXT NOT NULL,
                userId INTEGER REFERENCES user(id)
            );;
            """
        ]
    }
    var queriesQueries: QueriesQueriesImpl {
        QueriesQueriesImpl(connection: connection)
    }
}

typealias InsertUserQuery = Query<InsertUserInput, ()>
extension Query where Input == InsertUserInput {
    func execute(id: Int, firstName: String, lastName: String, preference: Bool?, favoriteNumber: Int?, randomValue: SQLAny?, bornOn: Date?) async throws -> Output {
        try await execute(with: InsertUserInput(id: id, firstName: firstName, lastName: lastName, preference: preference, favoriteNumber: favoriteNumber, randomValue: randomValue, bornOn: bornOn))
    }
    
    func observe(id: Int, firstName: String, lastName: String, preference: Bool?, favoriteNumber: Int?, randomValue: SQLAny?, bornOn: Date?) -> any QueryObservation<Output> {
        observe(with: InsertUserInput(id: id, firstName: firstName, lastName: lastName, preference: preference, favoriteNumber: favoriteNumber, randomValue: randomValue, bornOn: bornOn))
    }
}

typealias SelectUsersQuery = Query<(), [User]>
typealias SelectUserByIdQuery = Query<Int, User?>
typealias SelectUserByIdsQuery = Query<[Int], [User]>
typealias SelectUserByNameQuery = Query<String, [User]>
typealias SelectUserWithManyInputsQuery = Query<SelectUserWithManyInputsInput, SelectUserWithManyInputsOutput?>
extension Query where Input == SelectUserWithManyInputsInput {
    func execute(id: Int, firstName: String) async throws -> Output {
        try await execute(with: SelectUserWithManyInputsInput(id: id, firstName: firstName))
    }
    
    func observe(id: Int, firstName: String) -> any QueryObservation<Output> {
        observe(with: SelectUserWithManyInputsInput(id: id, firstName: firstName))
    }
}

typealias SelectWithInterestQuery = Query<(), [SelectWithInterestOutput]>
typealias SelectWithOptionalInterestQuery = Query<(), [SelectWithOptionalInterestOutput]>
