import Foundation
import Otter

struct Interest: Hashable, Sendable, Identifiable, RowDecodable {
    let id: Int
    let value: String
    let userId: Int?
    
    static let nonOptionalIndices: [Int32] = [0, 1]
    
    init(
        row: borrowing Otter.Row,
        startingAt start: Int32
    ) throws(Otter.OtterError) {
        self.id = try row.value(at: start + 0)
        self.value = try row.value(at: start + 1)
        self.userId = try row.value(at: start + 2)
    }
    
    init(
        id: Int,
        value: String,
        userId: Int?
    ) {
        self.id = id
        self.value = value
        self.userId = userId
    }
}

struct User: Hashable, Sendable, Identifiable, RowDecodableWithAdapters {
    let id: Int
    let firstName: String
    let lastName: String
    let preference: Bool?
    let favoriteNumber: Int?
    let randomValue: SQLAny?
    let bornOn: Date?
    let fullName: String
    
    static let nonOptionalIndices: [Int32] = [0, 1, 2, 7]
    
    init(
        row: borrowing Otter.Row,
        startingAt start: Int32,
        adapters: DB.Adapters
    ) throws(Otter.OtterError) {
        self.id = try row.value(at: start + 0)
        self.firstName = try row.value(at: start + 1)
        self.lastName = try row.value(at: start + 2)
        self.preference = try row.optionalValue(at: start + 3, using: adapters.bool, storage: Int.self)
        self.favoriteNumber = try row.value(at: start + 4)
        self.randomValue = try row.value(at: start + 5)
        self.bornOn = try row.optionalValue(at: start + 6, using: adapters.customDate, storage: String.self)
        self.fullName = try row.value(at: start + 7)
    }
    
    init(
        id: Int,
        firstName: String,
        lastName: String,
        preference: Bool?,
        favoriteNumber: Int?,
        randomValue: SQLAny?,
        bornOn: Date?,
        fullName: String
    ) {
        self.id = id
        self.firstName = firstName
        self.lastName = lastName
        self.preference = preference
        self.favoriteNumber = favoriteNumber
        self.randomValue = randomValue
        self.bornOn = bornOn
        self.fullName = fullName
    }
}

struct InsertUserInput: Hashable, Sendable, Identifiable {
    let id: Int
    let firstName: String
    let lastName: String
    let preference: Bool?
    let favoriteNumber: Int?
    let randomValue: SQLAny?
    let bornOn: Date?
}

struct SelectUserWithManyInputsInput: Hashable, Sendable, Identifiable {
    let id: Int
    let firstName: String
}

@dynamicMemberLookup
struct SelectUserWithManyInputsOutput: Hashable, Sendable, RowDecodableWithAdapters {
    let user: User
    let favoriteNumber: Int
    
    static let nonOptionalIndices: [Int32] = []
    
    init(
        row: borrowing Otter.Row,
        startingAt start: Int32,
        adapters: DB.Adapters
    ) throws(Otter.OtterError) {
        self.user = try row.embedded(at: start + 0, adapters: adapters)
        self.favoriteNumber = try row.value(at: start + 8)
    }
    
    init(
        user: User,
        favoriteNumber: Int
    ) {
        self.user = user
        self.favoriteNumber = favoriteNumber
    }
    
    subscript<Value>(dynamicMember dynamicMember: KeyPath<User, Value>) -> Value {
        self.user[keyPath: dynamicMember]
    }
}

@dynamicMemberLookup
struct SelectWithInterestOutput: Hashable, Sendable, RowDecodableWithAdapters {
    let user: User
    let interest: Interest
    
    static let nonOptionalIndices: [Int32] = []
    
    init(
        row: borrowing Otter.Row,
        startingAt start: Int32,
        adapters: DB.Adapters
    ) throws(Otter.OtterError) {
        self.user = try row.embedded(at: start + 0, adapters: adapters)
        self.interest = try row.embedded(at: start + 8)
    }
    
    init(
        user: User,
        interest: Interest
    ) {
        self.user = user
        self.interest = interest
    }
    
    subscript<Value>(dynamicMember dynamicMember: KeyPath<User, Value>) -> Value {
        self.user[keyPath: dynamicMember]
    }
    
    subscript<Value>(dynamicMember dynamicMember: KeyPath<Interest, Value>) -> Value {
        self.interest[keyPath: dynamicMember]
    }
}

@dynamicMemberLookup
struct SelectWithOptionalInterestOutput: Hashable, Sendable, RowDecodableWithAdapters {
    let user: User
    let interest: Interest?
    
    static let nonOptionalIndices: [Int32] = []
    
    init(
        row: borrowing Otter.Row,
        startingAt start: Int32,
        adapters: DB.Adapters
    ) throws(Otter.OtterError) {
        self.user = try row.embedded(at: start + 0, adapters: adapters)
        self.interest = try row.optionallyEmbedded(at: start + 8)
    }
    
    init(
        user: User,
        interest: Interest?
    ) {
        self.user = user
        self.interest = interest
    }
    
    subscript<Value>(dynamicMember dynamicMember: KeyPath<User, Value>) -> Value {
        self.user[keyPath: dynamicMember]
    }
    
    subscript<Value>(dynamicMember dynamicMember: KeyPath<Interest, Value>) -> Value? {
        self.interest?[keyPath: dynamicMember]
    }
}

struct QueriesQueries {
    var insertUser: any InsertUserQuery
    var selectUsers: any SelectUsersQuery
    var selectUserById: any SelectUserByIdQuery
    var selectUserByIds: any SelectUserByIdsQuery
    var selectUserByName: any SelectUserByNameQuery
    var selectUserWithManyInputs: any SelectUserWithManyInputsQuery
    var selectWithInterest: any SelectWithInterestQuery
    var selectWithOptionalInterest: any SelectWithOptionalInterestQuery
    
    static func noop(
        insertUser: any InsertUserQuery = Queries.Just(0),
        selectUsers: any SelectUsersQuery = Queries.Just(),
        selectUserById: any SelectUserByIdQuery = Queries.Just(),
        selectUserByIds: any SelectUserByIdsQuery = Queries.Just(),
        selectUserByName: any SelectUserByNameQuery = Queries.Just(),
        selectUserWithManyInputs: any SelectUserWithManyInputsQuery = Queries.Just(),
        selectWithInterest: any SelectWithInterestQuery = Queries.Just(),
        selectWithOptionalInterest: any SelectWithOptionalInterestQuery = Queries.Just()
    ) -> QueriesQueries {
        QueriesQueries(
            insertUser: insertUser,
            selectUsers: selectUsers,
            selectUserById: selectUserById,
            selectUserByIds: selectUserByIds,
            selectUserByName: selectUserByName,
            selectUserWithManyInputs: selectUserWithManyInputs,
            selectWithInterest: selectWithInterest,
            selectWithOptionalInterest: selectWithOptionalInterest
        )
    }
    
    static func live(connection: Connection, adapters: DB.Adapters) -> QueriesQueries {
        return QueriesQueries(
            insertUser: DatabaseQuery<InsertUserInput, Int>(
                .write,
                in: connection,
                watchingTables: ["user"]
            ) { input, tx in
                let statement = try Otter.Statement(
                    """
                    INSERT INTO user VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id
                    """,
                    transaction: tx
                )
                try statement.bind(value: input.id, to: 1)
                try statement.bind(value: input.firstName, to: 2)
                try statement.bind(value: input.lastName, to: 3)
                try statement.bind(value: input.preference, to: 4, using: adapters.bool, as: Int.self)
                try statement.bind(value: input.favoriteNumber, to: 5)
                try statement.bind(value: input.randomValue, to: 6)
                try statement.bind(value: input.bornOn, to: 7, using: adapters.customDate, as: String.self)
                return try statement.fetchOne()
            },
            selectUsers: DatabaseQuery<(), [User]>(
                .read,
                in: connection,
                watchingTables: ["user"]
            ) { input, tx in
                let statement = try Otter.Statement(
                    """
                    SELECT * FROM user
                    """,
                    transaction: tx
                )
                return try statement.fetchAll(adapters: adapters)
            },
            selectUserById: DatabaseQuery<Int, User?>(
                .read,
                in: connection,
                watchingTables: ["user"]
            ) { input, tx in
                let statement = try Otter.Statement(
                    """
                    SELECT * FROM user WHERE id = ?
                    """,
                    transaction: tx
                )
                try statement.bind(value: input, to: 1)
                return try statement.fetchOne(adapters: adapters)
            },
            selectUserByIds: DatabaseQuery<[Int], [User]>(
                .read,
                in: connection,
                watchingTables: ["user"]
            ) { input, tx in
                let statement = try Otter.Statement(
                    """
                    SELECT * FROM user WHERE id IN (\(input.sqlQuestionMarks))
                    """,
                    transaction: tx
                )
                for element in input {
                    try statement.bind(value: element.input, to: 1)
                }
                return try statement.fetchAll(adapters: adapters)
            },
            selectUserByName: DatabaseQuery<String, [User]>(
                .read,
                in: connection,
                watchingTables: ["user"]
            ) { input, tx in
                let statement = try Otter.Statement(
                    """
                    SELECT * FROM user WHERE fullName LIKE ?
                    """,
                    transaction: tx
                )
                try statement.bind(value: input, to: 1)
                return try statement.fetchAll(adapters: adapters)
            },
            selectUserWithManyInputs: DatabaseQuery<SelectUserWithManyInputsInput, SelectUserWithManyInputsOutput?>(
                .read,
                in: connection,
                watchingTables: ["user"]
            ) { input, tx in
                let statement = try Otter.Statement(
                    """
                    SELECT *, 1 AS favoriteNumber FROM user WHERE id = ? AND firstName = ?
                    """,
                    transaction: tx
                )
                try statement.bind(value: input.id, to: 1)
                try statement.bind(value: input.firstName, to: 2)
                return try statement.fetchOne(adapters: adapters)
            },
            selectWithInterest: DatabaseQuery<(), [SelectWithInterestOutput]>(
                .read,
                in: connection,
                watchingTables: ["interest","user"]
            ) { input, tx in
                let statement = try Otter.Statement(
                    """
                    SELECT user.*, interest.* FROM user INNER JOIN interest ON user.id = interest.userId
                    """,
                    transaction: tx
                )
                return try statement.fetchAll(adapters: adapters)
            },
            selectWithOptionalInterest: DatabaseQuery<(), [SelectWithOptionalInterestOutput]>(
                .read,
                in: connection,
                watchingTables: ["interest","user"]
            ) { input, tx in
                let statement = try Otter.Statement(
                    """
                    SELECT user.*, interest.* FROM user LEFT OUTER JOIN interest ON user.id = interest.userId
                    """,
                    transaction: tx
                )
                return try statement.fetchAll(adapters: adapters)
            }
        )
    }
    
}

struct DB: Database{
    let connection: any Otter.Connection
    let adapters: Adapters
    
    struct Adapters: Otter.Adapters {
        let customDate: AnyDatabaseValueAdapter<Date>
        
        init(
            customDate: any DatabaseValueAdapter<Date>
        ) {
            self.customDate = AnyDatabaseValueAdapter<Date>(customDate)
        }
    }
    
    static var migrations: [String] {
        return [
            """
            CREATE TABLE user (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                firstName TEXT NOT NULL,
                lastName TEXT NOT NULL,
                preference INTEGER ,
                favoriteNumber INTEGER,
                randomValue ANY,
                bornOn TEXT ,
                fullName TEXT NOT NULL GENERATED ALWAYS AS (firstName || ' ' || lastName)
            );
            """,
            """
            CREATE TABLE interest (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                value TEXT NOT NULL,
                userId INTEGER REFERENCES user(id)
            );;
            """
        ]
    }
    var queriesQueries: QueriesQueries {
        QueriesQueries.live(connection: connection, adapters: adapters)
    }
}

typealias InsertUserQuery = Query<InsertUserInput, Int>
extension Query where Input == InsertUserInput {
    func execute(id: Int, firstName: String, lastName: String, preference: Bool?, favoriteNumber: Int?, randomValue: SQLAny?, bornOn: Date?) async throws -> Output {
        try await execute(with: InsertUserInput(id: id, firstName: firstName, lastName: lastName, preference: preference, favoriteNumber: favoriteNumber, randomValue: randomValue, bornOn: bornOn))
    }
    
    func execute(id: Int, firstName: String, lastName: String, preference: Bool?, favoriteNumber: Int?, randomValue: SQLAny?, bornOn: Date?, tx: borrowing Transaction) throws -> Output {
        try execute(with: InsertUserInput(id: id, firstName: firstName, lastName: lastName, preference: preference, favoriteNumber: favoriteNumber, randomValue: randomValue, bornOn: bornOn), tx: tx)
    }
    
    func observe(id: Int, firstName: String, lastName: String, preference: Bool?, favoriteNumber: Int?, randomValue: SQLAny?, bornOn: Date?) -> any QueryObservation<Output> {
        observe(with: InsertUserInput(id: id, firstName: firstName, lastName: lastName, preference: preference, favoriteNumber: favoriteNumber, randomValue: randomValue, bornOn: bornOn))
    }
}

typealias SelectUsersQuery = Query<(), [User]>
typealias SelectUserByIdQuery = Query<Int, User?>
typealias SelectUserByIdsQuery = Query<[Int], [User]>
typealias SelectUserByNameQuery = Query<String, [User]>
typealias SelectUserWithManyInputsQuery = Query<SelectUserWithManyInputsInput, SelectUserWithManyInputsOutput?>
extension Query where Input == SelectUserWithManyInputsInput {
    func execute(id: Int, firstName: String) async throws -> Output {
        try await execute(with: SelectUserWithManyInputsInput(id: id, firstName: firstName))
    }
    
    func execute(id: Int, firstName: String, tx: borrowing Transaction) throws -> Output {
        try execute(with: SelectUserWithManyInputsInput(id: id, firstName: firstName), tx: tx)
    }
    
    func observe(id: Int, firstName: String) -> any QueryObservation<Output> {
        observe(with: SelectUserWithManyInputsInput(id: id, firstName: firstName))
    }
}

typealias SelectWithInterestQuery = Query<(), [SelectWithInterestOutput]>
typealias SelectWithOptionalInterestQuery = Query<(), [SelectWithOptionalInterestOutput]>
